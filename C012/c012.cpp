

// 자연수가 주어졌을때 15라면 1부터 15까지의 숫자의 개수가 총 몇번 쓰였는지 카운트하는 알고리즘이다.
// 예를 들면 1 2 3 4 5 6 7 8 9 1 0 1 1 1 2 1 3 1 4 1 5 총 21번 카운트된다.
// 문제를 풀기 위해서 먼저 반복되는 패턴을 생각해보면
// 1 - 9 까지는 무조건 한번씩 숫자가 존재하고
// 10 - 99 까지는 두번
// 100 - 999 까지는 세번 
// 이런식으로 반복됨을 알 수 있다. 위 과정에 포함되는 숫자별로 곱해서 한계치를 구할수 있다. 
// 입력값 99이 주어진다면 (9 * 1) + (90 * 2) = 189
// 따라서 한계치(9/99/999)에 대한 결과값(1-99까지카운트된결과)을 계산해두고
// 계산된 결과값보다 작으면 계산된 결과값 - 입력값
// | 자리수 | 증가값 | 경계값  | 자리수별 결과값
// | cnt  | digit | bound | res (cnt * digit + bound)이전값계산
// | 1    | 9     | 0     | 0
// | 2    | 90    | 9     | 9
// | 3    | 900   | 99    | 189
// | 4    | 9000  | 999   | 2799

// 입력값 input이 bound값과 딱 떨어진다면 그대로 limit값을 출력하면 되지만 그렇지 않은경우를 대비하여
// 160이 들어오는 경우를 생각해보자
// 1. 먼저 위 테이블의 바운더리안에 포함되는지 확인하여 카운트값을 구한다.
//      160 < 999 이므로 cnt가 3이(세자리수) 된다.
// 2. 입력값에서 경계값을 제하고 카운트값을 곱하면 결과값이 된다.
//     (160 - 99) * 3 = (61 * 3) =  183
// 3. 2의 값을 자리수별 결과값에 더해준다.
//       183 + 189 = 372
// input(8)  = (8-0)*1 + 0 = 8;
// input(13) = (13-9)*2 + 9 = 17;
// input(160) = (160-99)*3 + 189 = 372;
// input(1600) = (1600-999)*4 + 2799 = 2404 + 2799 = 5203;
#include <stdio.h>

int main(){

	int n, digit=9, bound=0, cnt=1, res=0;
	scanf("%d", &n);
	
	while(n > (digit+bound)){
		res = (cnt*digit)+bound;
		bound += digit;
	   digit *= 10;
	   cnt++;
	}
	res += (n - bound) * cnt;
	printf("%d",res);
   return 0;

}
